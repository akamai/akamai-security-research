import ida_hexrays
import idaapi
import idc
import json

TEMP_OUTPUT_FILE = "ida_pro_rpc_auth_info.tmp"
PARSING_ERROR = "argument_parsing_error"

def find_imports(import_name, func_name):
    rpc_reg_imports = []

    def imp_cb(ea: int, name: str, ord: int) -> bool:
        if name and name == func_name:
            # print(name)
            rpc_reg_imports.append(ea)
        return True

    for i in range(idaapi.get_import_module_qty()):
        module_name = idaapi.get_import_module_name(i)
        if module_name.lower() != import_name:
            continue
        idaapi.enum_import_names(i, imp_cb)
    return rpc_reg_imports
        

def find_all_func_xrefs(func_ea: int):
    xref_eas = []
    func_xref = idaapi.get_first_cref_to(func_ea)
    while func_xref != idaapi.BADADDR:
        xref_eas.append(func_xref)
        func_xref = idaapi.get_next_cref_to(func_ea, func_xref)

    return xref_eas

def find_function_calls_with_parameter(import_name, function_name, argc, ind, val):
    req_val_calls = []
    unknown_val_calls = []

    for ea in find_imports(import_name, function_name):
        # print(function_name, ea)
        for xref in find_all_func_xrefs(ea):
            # The reason we use decompile instead of parsing the assembly ourselves is due to the many compiler optimizations involved in passing an integer as an argument.
            # We've see too many different ways of passing those fields that we gave up on parsing it reliably ourselves
            decomp = str(ida_hexrays.decompile(xref))
            for l in decomp.splitlines():
                # found = False
                cval = -1
                call_ind = l.find(function_name)
                if call_ind != -1:
                    # print(l)
                    args = l[l.find("(", call_ind)+1:l.rfind(")")].split(",")
                    if len(args) != argc:
                        unknown_val_calls.append(xref)
                        # print("argc")
                        continue
                    else:
                        cval = args[ind].strip()
                        print(cval)
                        if not cval[0].isdigit():
                            unknown_val_calls.append(xref)
                            # print("prefix")
                            continue
                        if cval[-1] == 'u':
                            cval = int(cval[:-1])
                        elif cval[-1] == 'h':
                            cval = int("0x"+cval[:-1])
                        elif not cval[-1].isdigit():
                            unknown_val_calls.append(xref)
                            # print("suffix")
                            continue
                        else:
                            cval = int(cval)
                        if cval <= val:
                            req_val_calls.append(xref)
                            # found = True
                    # print(hex(xref), l, args, cval, found)


    return req_val_calls, unknown_val_calls

# Example usage:
if __name__ == "__main__":
    idaapi.auto_wait()
    # we call the script from an outside python that runs Ida in headless mode for each file we want to analyze.
    req_a, unk_a = find_function_calls_with_parameter("rpcrt4", "RpcBindingSetAuthInfoA", 6, 2, 2)
    req_w, unk_w = find_function_calls_with_parameter("rpcrt4", "RpcBindingSetAuthInfoW", 6, 2, 2)
    req_exa, unk_exa = find_function_calls_with_parameter("rpcrt4", "RpcBindingSetAuthInfoExA", 7, 2, 2)
    req_exw, unk_exw = find_function_calls_with_parameter("rpcrt4", "RpcBindingSetAuthInfoExW", 7, 2, 2)

    req = [hex(ea) for ea in req_a + req_w + req_exa + req_exw]
    unk = [hex(ea) for ea in unk_a + unk_w + unk_exa + unk_exw]
    print({"req":req,"unk":unk})
    with open(TEMP_OUTPUT_FILE, "wt", newline="\n") as f:
        json.dump({"req":req,"unk":unk}, f)
    idaapi.qexit(0)
